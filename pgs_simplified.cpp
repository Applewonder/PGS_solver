# include <iostream>
# include <vector>
#include <assert.h>
#include <Eigen/Dense>

using namespace std;

typedef Eigen::Matrix<long double, Eigen::Dynamic, Eigen::Dynamic> MAT; 
typedef Eigen::Matrix<long double, Eigen::Dynamic, 1> VEC;


int n = 12;
MAT A = MAT::Zero(n, n);
VEC B = VEC::Zero(n);
VEC lo = VEC::Zero(n);
VEC hi = VEC::Zero(n);
VEC mlo = VEC::Zero(n);
VEC mhi = VEC::Zero(n);
VEC X_k = VEC::Zero(n);
VEC X_k_1 = VEC::Zero(n);
VEC W = VEC::Zero(n);
MAT L = MAT::Zero(n, n);
MAT U = MAT::Zero(n, n);
MAT D = MAT::Zero(n, n);
VEC Findex = VEC::Zero(n);
MAT reverseD_L = MAT::Zero(n, n);



void input() {
    A <<    1.001372, 0.000623, 0.000616, 1.000018, 0.000627, 0.000620, 0.999555, 0.000633, 0.000627, 1.000809, 0.000629, 0.000623, 
            0.000623, 1.001332, -0.000636, 0.000623, 0.999982, -0.000636, 0.000174, 0.999989, -0.000178, 0.000174, 1.001239, -0.000178, 
            0.000616, -0.000636, 1.001346, -0.000612, 0.000632, 1.001250, -0.000612, 0.000632, 1.000793, 0.000616, -0.000636, 1.000789, 
            1.000018, 0.000623, -0.000612, 1.001363, 0.000627, -0.000616, 1.000801, 0.000633, -0.000623, 0.999555, 0.000629, -0.000618, 
            0.000627, 0.999982, 0.000632, 0.000627, 1.001332, 0.000632, 0.000175, 1.001239, 0.000177, 0.000175, 0.999989, 0.000177, 
            0.000620, -0.000636, 1.001250, -0.000616, 0.000632, 1.001354, -0.000616, 0.000632, 1.000798, 0.000620, -0.000636, 1.000793, 
            0.999555, 0.000174, -0.000612, 1.000801, 0.000175, -0.000616, 1.000771, 0.000177, -0.000623, 0.999425, 0.000176, -0.000618, 
            0.000633, 0.999989, 0.000632, 0.000633, 1.001239, 0.000632, 0.000177, 1.001345, 0.000177, 0.000177, 0.999995, 0.000177, 
            0.000627, -0.000178, 1.000793, -0.000623, 0.000177, 1.000798, -0.000623, 0.000177, 1.000775, 0.000627, -0.000178, 1.000670, 
            1.000809, 0.000174, 0.000616, 0.999555, 0.000175, 0.000620, 0.999425, 0.000177, 0.000627, 1.000779, 0.000176, 0.000623, 
            0.000629, 1.001239, -0.000636, 0.000629, 0.999989, -0.000636, 0.000176, 0.999995, -0.000178, 0.000176, 1.001345, -0.000178, 
            0.000623, -0.000178, 1.000789, -0.000618, 0.000177, 1.000793, -0.000618, 0.000177, 1.000670, 0.000623, -0.000178, 1.000766;
    B <<    0.097388, 4.129116, -0.000028, 0.097397, 4.129111, -0.000028, 0.097978, 4.129103, -0.000028, 0.097969, 4.129108, -0.000028;
    lo <<   0, -1, -1, 0, -1, -1, 0, -1, -1, 0, -1, -1;      
    hi <<   -2, 1, 1, -2, 1, 1, -2, 1, 1, -2, 1, 1;
    X_k <<    0.047213, 0.000000, 0.000000, 0.002361, 0.000000, 0.000000, 0.049384, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000;
    Findex << -1, 0, 0, -1, 3, 3, -1, 6, 6, -1, 9, 9;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            long double var = 0;
            var = A(i, j);
            if (j == i) {
                D(i, i) = var;
            } else if (j > i) {
                U(i, j) = -var;
            } else if (j < i) {
                L(i, j) = -var;
            }
        }
    }
}

void renew_hi_lo() {
    for (int i = 0; i < n; i++)
    {   
        int index = Findex(i);
        if (index != -1) {
            mhi(i) = X_k_1(index)*hi(i);
            mlo(i) = X_k_1(index)*lo(i);
        } else {
            mhi(i) = hi(i);
            mlo(i) = lo(i);
        }
    }
    // cout << "mhi is :" << mhi << endl;
    // cout << endl;
    // cout << "mlo is :" << mlo << endl;
    // cout << endl;
}

void renew_origin_hi_lo() {
    for (int i = 0; i < n; i++)
    {   
        int index = Findex(i);
        if (index != -1) {
            mhi(i) = X_k(index)*hi(i);
            mlo(i) = X_k(index)*lo(i);
        } else {
            mhi(i) = hi(i);
            mlo(i) = lo(i);
        }
    }
    // cout << "mhi is :" << mhi << endl;
    // cout << endl;
    // cout << "mlo is :" << mlo << endl;
    // cout << endl;
}

void renew_x_k() {
    for (int i = 0; i < n; i++)
    {
        if (X_k_1(i) > mhi(i) && mhi(i) != -2) X_k_1(i) = mhi(i);
        if (X_k_1(i) < mlo(i) && mlo(i) != -2) X_k_1(i) = mlo(i);
    }
    // cout << "x_k_1 is :" << X_k_1 << endl;
    // cout << endl;
}

bool judge_if_positive_definite() {
    MAT ml = A.llt().matrixL();
    cout << ml << endl;
    ml = ml*ml.transpose();
    if (ml == A) {
        return true;
    } else {
        cout << ml;
        return false;
    }
    
}

void one_step() {
    X_k_1 = U*X_k;
    // cout << X_k_1 << endl;
    // cout << endl;
    X_k_1 = X_k_1 - B;
    // cout << X_k_1 << endl;
    // cout << endl;
    X_k_1 = reverseD_L * X_k_1;
    // cout << X_k_1 << endl;
    // cout << endl;
}



void find_reverse_DL() {
    reverseD_L = D - L;
    reverseD_L = reverseD_L.inverse();
//     cout << "reverse D - L is: " << endl << reverseD_L << endl;
//     cout << endl;
}

bool judge_stop() {
    if((X_k_1 - X_k).norm() < 1e-5) return true;
    X_k = X_k_1;
    return false;
}

int main() {
    input();
    //judge_if_positive_definite();
    find_reverse_DL();
    // for (int i = 0; i < n; i++)
    // {   
    //     int index = Findex(i);
    //     if (index != -1) {
    //         mhi(i) = X_k(index)*hi(i);
    //         mlo(i) = X_k(index)*lo(i);
    //     } else {
    //         mhi(i) = hi(i);
    //         mlo(i) = lo(i);
    //     }
    // }
    mhi = hi;
    mlo = lo;
    // cout << "mhi is :" << mhi << endl;
    // cout << endl;
    // cout << "mlo is :" << mlo << endl;
    // cout << endl;
    int count = 0;
    do {
        one_step();
        renew_x_k();
        renew_hi_lo();
        count ++;
        if (count > 10000) {
            cout << "----------------------->failed" << endl;
            break;
        }
    } while(!judge_stop());
    cout << X_k_1 << endl;
    cout << endl;
    X_k = A*X_k_1 + B;
    cout << X_k << endl;
    cout << endl;
    return 0;
}

// 1.001250, 0.000625, 0.000625, 1.000000, 0.000625, 0.000625, 0.998750, 0.000625, 0.000625, 1.000000, 0.000625, 0.000625, 
// 0.000625, 1.001250, -0.000625, 0.000625, 1.000000, -0.000625, -0.000625, 1.000000, 0.000625, -0.000625, 1.001250, 0.000625, 
// 0.000625, -0.000625, 1.001250, -0.000625, 0.000625, 1.001250, -0.000625, 0.000625, 1.000000, 0.000625, -0.000625, 1.000000, 
// 1.000000, 0.000625, -0.000625, 1.001250, 0.000625, -0.000625, 1.000000, 0.000625, -0.000625, 0.998750, 0.000625, -0.000625, 
// 0.000625, 1.000000, 0.000625, 0.000625, 1.001250, 0.000625, -0.000625, 1.001250, -0.000625, -0.000625, 1.000000, -0.000625, 
// 0.000625, -0.000625, 1.001250, -0.000625, 0.000625, 1.001250, -0.000625, 0.000625, 1.000000, 0.000625, -0.000625, 1.000000, 
// 0.998750, -0.000625, -0.000625, 1.000000, -0.000625, -0.000625, 1.001250, -0.000625, -0.000625, 1.000000, -0.000625, -0.000625, 
// 0.000625, 1.000000, 0.000625, 0.000625, 1.001250, 0.000625, -0.000625, 1.001250, -0.000625, -0.000625, 1.000000, -0.000625, 
// 0.000625, 0.000625, 1.000000, -0.000625, -0.000625, 1.000000, -0.000625, -0.000625, 1.001250, 0.000625, 0.000625, 1.001250, 
// 1.000000, -0.000625, 0.000625, 0.998750, -0.000625, 0.000625, 1.000000, -0.000625, 0.000625, 1.001250, -0.000625, 0.000625, 
// 0.000625, 1.001250, -0.000625, 0.000625, 1.000000, -0.000625, -0.000625, 1.000000, 0.000625, -0.000625, 1.001250, 0.000625, 
// 0.000625, 0.000625, 1.000000, -0.000625, -0.000625, 1.000000, -0.000625, -0.000625, 1.001250, 0.000625, 0.000625, 1.001250

// 1.001250, 0.000625, 0.000625, 1.000000, 0.000625, 0.000625, 0.998750, 0.000625, 0.000625, 1.000000, 0.000625, 0.000625, 
// 0.000625, 1.001250, -0.000625, 0.000625, 1.000000, -0.000625, -0.000625, 1.000000, 0.000625, -0.000625, 1.001250, 0.000625, 
// 0.000625, -0.000625, 1.001250, -0.000625, 0.000625, 1.001250, -0.000625, 0.000625, 1.000000, 0.000625, -0.000625, 1.000000, 
// 1.000000, 0.000625, -0.000625, 1.001250, 0.000625, -0.000625, 1.000000, 0.000625, -0.000625, 0.998750, 0.000625, -0.000625, 
// 0.000625, 1.000000, 0.000625, 0.000625, 1.001250, 0.000625, -0.000625, 1.001250, -0.000625, -0.000625, 1.000000, -0.000625, 
// 0.000625, -0.000625, 1.001250, -0.000625, 0.000625, 1.001250, -0.000625, 0.000625, 1.000000, 0.000625, -0.000625, 1.000000, 
// 0.998750, -0.000625, -0.000625, 1.000000, -0.000625, -0.000625, 1.001250, -0.000625, -0.000625, 1.000000, -0.000625, -0.000625, 
// 0.000625, 1.000000, 0.000625, 0.000625, 1.001250, 0.000625, -0.000625, 1.001250, -0.000625, -0.000625, 1.000000, -0.000625, 
// 0.000625, 0.000625, 1.000000, -0.000625, -0.000625, 1.000000, -0.000625, -0.000625, 1.001250, 0.000625, 0.000625, 1.001250, 
// 1.000000, -0.000625, 0.000625, 0.998750, -0.000625, 0.000625, 1.000000, -0.000625, 0.000625, 1.001250, -0.000625, 0.000625, 
// 0.000625, 1.001250, -0.000625, 0.000625, 1.000000, -0.000625, -0.000625, 1.000000, 0.000625, -0.000625, 1.001250, 0.000625, 
// 0.000625, 0.000625, 1.000000, -0.000625, -0.000625, 1.000000, -0.000625, -0.000625, 1.001250, 0.000625, 0.000625, 1.001250; 



//     // 解方程
//     // 我们求解 A * x = b 这个方程
//     // 直接求逆自然是最直接的，但是求逆运算量大
 
//     Eigen::Matrix< double, Eigen::Dynamic, Eigen::Dynamic > A1;
//     A1 = Eigen::MatrixXd::Random( MATRIX_SIZE, MATRIX_SIZE );
 
//     Eigen::Matrix< double, Eigen::Dynamic, Eigen::Dynamic > b1;
//     b1 = Eigen::MatrixXd::Random( MATRIX_SIZE, 1 );
 
//     clock_t time_stt = clock(); // 计时
//     // 直接求逆
//     Eigen::Matrix<double,MATRIX_SIZE,1> x = A1.inverse()*b1;
//     cout <<"time use in normal inverse is " << 1000* (clock() - time_stt)/(double)CLOCKS_PER_SEC << "ms"<< endl;
//     cout<<x<<endl;
//     // QR分解colPivHouseholderQr()
//     time_stt = clock();
//     x = A1.colPivHouseholderQr().solve(b1);
//     cout <<"time use in Qr decomposition is " <<1000*(clock() - time_stt)/(double)CLOCKS_PER_SEC <<"ms" << endl;
//     cout <<x<<endl;
//     //QR分解fullPivHouseholderQr()
//     time_stt = clock();
//     x = A1.fullPivHouseholderQr().solve(b1);
//     cout <<"time use in Qr decomposition is " <<1000*(clock() - time_stt)/(double)CLOCKS_PER_SEC <<"ms" << endl;
//     cout <<x<<endl;
//     /* //llt分解 要求矩阵A正定
//     time_stt = clock();
//     x = A1.llt().solve(b1);
//     cout <<"time use in llt decomposition is " <<1000*(clock() - time_stt)/(double)CLOCKS_PER_SEC <<"ms" << endl;
//     cout <<x<<endl;*/
//     /*//ldlt分解  要求矩阵A正或负半定
//     time_stt = clock();
//     x = A1.ldlt().solve(b1);
//     cout <<"time use in ldlt decomposition is " <<1000*(clock() - time_stt)/(double)CLOCKS_PER_SEC <<"ms" << endl;
//     cout <<x<<endl;*/
//     //lu分解 partialPivLu()
//     time_stt = clock();
//     x = A1.partialPivLu().solve(b1);
//     cout <<"time use in lu decomposition is " <<1000*(clock() - time_stt)/(double)CLOCKS_PER_SEC <<"ms" << endl;
//     cout <<x<<endl;
//     //lu分解（fullPivLu()
//     time_stt = clock();
//     x = A1.fullPivLu().solve(b1);
//     cout <<"time use in lu decomposition is " <<1000*(clock() - time_stt)/(double)CLOCKS_PER_SEC <<"ms" << endl;
//     cout <<x<<endl;
// ————————————————

   //  -0.063, -0.157579, 0.000118027, -0.189039, -0.472421, 1.72004e-07, -0.75482, -1.10164, 0.00188636, -1.88528, -2.35739, 0.000790098